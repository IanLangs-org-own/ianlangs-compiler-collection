#pragma once
#include <cmath>
#include <limits>
#include <vector>
#include <string>
#include <numeric>
#include <stdexcept>
#include <cctype>
#include <algorithm>
#include <flow/vector>
namespace flow {

    // ==========================================================
    // CONSTANTES FUNDAMENTALES
    // ==========================================================
    inline constexpr long double PI  = 3.141592653589793238462643383279502884L;
    inline constexpr long double TAU = 2.0L * PI;
    inline constexpr long double E   = 2.718281828459045235360287471352662498L;

    inline constexpr long double INF     = std::numeric_limits<long double>::infinity();
    inline constexpr long double NAN_VAL = std::numeric_limits<long double>::quiet_NaN();
    inline constexpr long double EPS     = 1e-12L;

    // ==========================================================
    // UTILIDADES BÁSICAS
    // ==========================================================
    inline long double abs(long double x) { return std::fabs(x); }

    template<typename T>
    inline T min(const T& a, const T& b) { return (a < b) ? a : b; }

    template<typename T>
    inline T max(const T& a, const T& b) { return (a > b) ? a : b; }

    template<typename T>
    inline T clamp(T x, T lo, T hi) {
        return (x < lo) ? lo : (x > hi ? hi : x);
    }

    inline int sign(long double x) {
        if (x > 0) return 1;
        if (x < 0) return -1;
        return 0;
    }

    inline bool almost_equal(long double a, long double b, long double eps = EPS) {
        return abs(a - b) <= eps;
    }

    inline bool isnan(long double x) { return std::isnan(x); }
    inline bool isinf(long double x) { return std::isinf(x); }

    inline long double lerp(long double a, long double b, long double t) {
        return a + (b - a) * t;
    }

    // ==========================================================
    // TRIGONOMETRÍA Y LOGARITMOS
    // ==========================================================
    inline constexpr long double deg2rad(long double d) { return d * PI / 180.0L; }
    inline constexpr long double rad2deg(long double r) { return r * 180.0L / PI; }

    using std::sin;
    using std::cos;
    using std::tan;
    using std::asin;
    using std::acos;
    using std::atan;
    using std::atan2;

    using std::exp;
    using std::log;
    using std::log10;

    inline long double ln(long double x) { return log(x); }
    inline long double log_base(long double x, long double base) {
        return log(x) / log(base);
    }

    using std::sqrt;
    using std::cbrt;
    using std::pow;

    using std::floor;
    using std::ceil;
    using std::round;
    using std::trunc;

    // ==========================================================
    // ESTADÍSTICA
    // ==========================================================
    template<typename T>
    inline T sum(const vector<T>& v) {
        return std::accumulate(v.begin(), v.end(), T(0));
    }

    template<typename T>
    inline long double mean(const vector<T>& v) {
        if (v.empty()) throw std::domain_error("mean: vector vacío");
        return static_cast<long double>(sum(v)) / v.size();
    }

    template<typename T>
    inline long double variance_population(const vector<T>& v) {
        if (v.empty()) throw std::domain_error("variance: vector vacío");
        long double m = mean(v);
        long double s = 0;
        for (auto x : v) s += (x - m) * (x - m);
        return s / v.size();
    }

    template<typename T>
    inline long double variance_sample(const vector<T>& v) {
        if (v.size() < 2) throw std::domain_error("variance_sample: tamaño < 2");
        long double m = mean(v);
        long double s = 0;
        for (auto x : v) s += (x - m) * (x - m);
        return s / (v.size() - 1);
    }

    template<typename T>
    inline long double stdev_population(const vector<T>& v) {
        return sqrt(variance_population(v));
    }

    template<typename T>
    inline long double stdev_sample(const vector<T>& v) {
        return sqrt(variance_sample(v));
    }

    template<typename T>
    inline T median(vector<T> v) {
        if (v.empty()) throw std::domain_error("median: vector vacío");
        std::sort(v.begin(), v.end());
        size_t n = v.size();
        if (n % 2 == 1) return v[n / 2];
        return (v[n / 2 - 1] + v[n / 2]) / 2;
    }

    // ==========================================================
    // MATRICES
    // ==========================================================

    template<typename T>
    matrix<T> zeros(size_t r, size_t c) {
        return matrix<T>(r, vector<T>(c, T(0)));
    }

    template<typename T>
    matrix<T> identity(size_t n) {
        matrix<T> I = zeros<T>(n, n);
        for (size_t i = 0; i < n; ++i) I[i][i] = T(1);
        return I;
    }

    template<typename T>
    matrix<T> transpose(const matrix<T>& M) {
        if (M.empty()) throw std::domain_error("transpose: matriz vacía");
        matrix<T> R = zeros<T>(M[0].size(), M.size());
        for (size_t i = 0; i < M.size(); ++i)
            for (size_t j = 0; j < M[0].size(); ++j)
                R[j][i] = M[i][j];
        return R;
    }

    template<typename T>
    matrix<T> matmul(const matrix<T>& A, const matrix<T>& B) {
        if (A.empty() || B.empty())
            throw std::domain_error("matmul: matriz vacía");
        if (A[0].size() != B.size())
            throw std::domain_error("matmul: dimensiones incompatibles");

        size_t n = A.size(), m = B[0].size(), p = B.size();
        matrix<T> C = zeros<T>(n, m);

        for (size_t i = 0; i < n; ++i)
            for (size_t j = 0; j < m; ++j)
                for (size_t k = 0; k < p; ++k)
                    C[i][j] += A[i][k] * B[k][j];
        return C;
    }

    // ==========================================================
    // COMBINATORIA
    // ==========================================================
    inline long double factorial(int n) {
        if (n < 0) throw std::domain_error("factorial: n negativo");
        long double r = 1;
        for (int i = 2; i <= n; ++i) r *= i;
        return r;
    }

    inline long double nCr(int n, int r) {
        if (r < 0 || n < 0 || r > n)
            throw std::domain_error("nCr: valores inválidos");
        r = min(r, n - r);
        long double res = 1;
        for (int i = 1; i <= r; ++i)
            res = res * (n - r + i) / i;
        return res;
    }

    // ==========================================================
    // CONVERSIÓN DE BASES
    // ==========================================================
    inline std::string to_base(long double n, int base, int precision = 12) {
        if (base < 2 || base > 36)
            throw std::domain_error("to_base: base inválida");

        const std::string chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        bool neg = n < 0;
        if (neg) n = -n;

        long long ip = static_cast<long long>(n);
        long double fp = n - ip;

        std::string i;
        do {
            i = chars[ip % base] + i;
            ip /= base;
        } while (ip > 0);

        std::string f;
        while (fp > 0 && precision--) {
            fp *= base;
            int d = static_cast<int>(fp);
            f += chars[d];
            fp -= d;
        }

        std::string r = i;
        if (!f.empty()) r += "." + f;
        if (neg) r = "-" + r;
        return r;
    }

    inline long double from_base(const std::string& s, int base) {
        if (base < 2 || base > 36)
            throw std::domain_error("from_base: base inválida");

        const std::string chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        size_t dot = s.find('.');
        std::string i = (dot == std::string::npos) ? s : s.substr(0, dot);
        std::string f = (dot == std::string::npos) ? "" : s.substr(dot + 1);

        bool neg = false;
        size_t start = 0;
        if (!i.empty() && i[0] == '-') { neg = true; start = 1; }

        long double r = 0;
        for (size_t k = start; k < i.size(); ++k) {
            char c = std::toupper(i[k]);
            size_t v = chars.find(c);
            if (v == std::string::npos || v >= (size_t)base)
                throw std::domain_error("from_base: caracter inválido");
            r = r * base + v;
        }

        long double mul = 1.0L / base;
        for (char c : f) {
            char u = std::toupper(c);
            size_t v = chars.find(u);
            if (v == std::string::npos || v >= (size_t)base)
                throw std::domain_error("from_base: caracter inválido");
            r += v * mul;
            mul /= base;
        }

        return neg ? -r : r;
    }
    inline long double arrow(long double a, long double b, int n) {
        if (n < 0) throw std::domain_error("arrow: n inválido");
        if (n == 0) return a * b;
        if (n == 1) return pow(a, b);
        if (b == 0) return 1;

        long double r = a;
        for (long double i = 1; i < b; ++i)
            r = arrow(a, r, n - 1);
        return r;
    }

    long double H(long double a, long double b, int n) {
        if (n == 0) return b + 1;
        if (n == 1) return a + b;
        if (n == 2) return a * b;
        if (b == 0) return 1; // depende del nivel
        return H(a, H(a, b - 1, n), n - 1);
    }

} // namespace flow
